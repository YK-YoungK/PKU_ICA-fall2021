/*
5. 猴子分苹果
题目描述
有1堆苹果共 m 个，由 n 只猴子按个数平均分配。每次到达苹果堆放地的猴子只有1只，而且每个猴子都会平均分 1 次苹果。第1个到达的猴子将苹果平均分成 n 等份，但发现多 k ( k < n )个，于是，将多余的k个扔掉，然后拿走其中的1等份。第 2 个猴子同样将剩余的苹果又分成 n 等份，也发现多 k 个，并同样将多余的 k 个扔掉，然后拿走其中1等份。之后的每个猴子都这样（将剩余的苹果又分成 n 等份，也发现多 k 个，并将多余的 k 个扔掉，然后拿走其中1等份）。假设最后的猴子分配后至少可以拿走1个苹果，请根据输入的 n 和 k值，计算最小的 m

关于输入
输入猴子数目n 和扔掉的个数 k，其中 k 小于 n，n 和 k 之间以空格间隔。

关于输出
输出最小苹果数目

例子输入
2 1
例子输出
7
提示信息
*/
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
	//推导发现最后一只拿的苹果i满足：(n-1)^(n-1)|i+k
	int i = 0, k = 0, n = 0;
	cin >> n >> k;
	if (n == 1)
		cout << "1" << endl;
	if (n == 2)
	{
		if (k == 1)
			cout << "7" << endl;
		if (k == 0)
			cout << "4" << endl;
	}
	if (n >= 3)
	{
		i = pow(n - 1, n - 1) - k;
		int result = n * i + k;
		for (int i = n - 1; i >= 1; i--)
		{
			result = result / (n - 1) * n + k;
		}
		cout << result << endl;
	}
	return 0;
}